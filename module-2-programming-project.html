<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CMPS 260: Module 2 Programming Project</title>
<style>* { font-family: monospace; }</style>
<script>

// NOTE: You must implement the data structures using the prototype approach.
//       This is not what the book uses, so you have to convert it.
//       See also: https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/

// NOTE: Please review the following links regularly:
//       https://it.pointpark.edu/tutorials/arrays-vs-objects/
//       https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/
//       https://it.pointpark.edu/tutorials/implementation-vs-interface/



//---------//
// Project //
//---------//
console.log("Project");

// 1. Implement the stack data structure using the prototype.

function Stack() {
  this.items = [];
}
Stack.prototype.push = function(x){
  this.items.push(x);
}
Stack.prototype.pop = function(){
  return this.items.pop();
}
Stack.prototype.peek = function(){
  return this.items[this.items.length-1];
}
Stack.prototype.isEmpty = function(){
  return this.items.length === 0;
}
Stack.prototype.clear = function(){
  this.items = [];
}
Stack.prototype.size = function(){
  return this.items.length;
}
Stack.prototype.print = function(){
  console.log(this.items.toString());
}
// 2. It is possible to use a stack to check if the number of parentheses in a
//    string is balanced, meaning there are as many opening parentheses as
//    closing ones. In addition, we can also make sure that each opening
//    parenthesis precedes a closing parenthesis. Implement this algorithm.
//    HINT: When encountering '(' push to the stack and when encountering ')'
//    pop from the stack.

function isBalanced(str) {
  var count = 0;
  while (str.size() > 0){
    var temp = str.pop();
    if (temp === ")"){
      count++;
    }
    else if (temp === "("){
      count--;
    }
    }
  if (count === 0){
    return true;
  }
  return false;
}


// 3. Write a simple test program that shows your implementation in the
//    previous question works.

var strVar = "(This is (balanced.))"
var stack = new Stack();
var tempArray = strVar.split("");
for (var i = 0; i < tempArray.length; i++){
  stack.push(tempArray[i]);
}
console.log(isBalanced(stack)?"This string has balanced parentheses.":"This string does not have balanced parenthesis.");

var strVar2 = "This ( is not ) balanced. )"
var stack2 = new Stack();
var tempArray2 = strVar2.split("");
for (var i = 0; i < tempArray2.length; i++){
  stack2.push(tempArray2[i]);
}
console.log(isBalanced(stack2)?"This string has balanced parentheses.":"This string does not have balanced parenthesis.");
// 4. Implement the queue data structure using the prototype.

function Queue() {
  this.items = [];
}
Queue.prototype.enqueue = function(x) {
  this.items.push(x);
}
Queue.prototype.dequeue = function() {
  return this.items.shift();
}
Queue.prototype.front = function() {
  return this.items[0];
}
Queue.prototype.isEmpty = function() {
  return this.items.length === 0;
}
Queue.prototype.size = function() {
  return this.items.length;
}
Queue.prototype.print = function() {
  console.log(this.items.toString());
}

// 5. Create a queue that stores edibles, that can be either fruits or
//    vegetables. Use the constructor below to create the edible and store a
//    few of each kind in the queue (at least 3 of each).

function Edible(name, isFruit) {
  this.name = name;
  this.isFruit = isFruit; // if not fruit, it must be a vegetable
  this.toString = function() {
    return "Edible: " + this.name + " Fruit: " + this.isFruit;
  };
}

var foodQueue = new Queue();
foodQueue.enqueue(new Edible("Broccoli", false));
foodQueue.enqueue(new Edible("Grape", true));
foodQueue.enqueue(new Edible("Green Bean", false));
foodQueue.enqueue(new Edible("Apple", true));
foodQueue.enqueue(new Edible("Peach", true));
foodQueue.enqueue(new Edible("Cucumber", false));


// 6. Create two more queues: one for fruits and one for vegetables. For this
//    question, only create them (and leave them empty).

var fruitQueue = new Queue();
var veggieQueue = new Queue();

// 7. Dequeue all the elements from the edible queue and enqueue them in the
//    appropriate queue, either for fruits or vegetables.

while (foodQueue.size() > 0){
  var temp = foodQueue.dequeue();
  if(temp.isFruit){
    fruitQueue.enqueue(temp);
  }
  else{
    veggieQueue.enqueue(temp);
  }
}

// 8. Print the final contents to the console, showing that your code works.
console.log("Food Queue contains:");
foodQueue.print();
console.log("Fruit Queue contains:");
fruitQueue.print();
console.log("Veggie Queue contains:");
veggieQueue.print();


</script>
</head>
<body>
  See console!
</body>
</html>
